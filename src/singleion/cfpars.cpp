/* cfpars.cpp
 * 
 * A class encapsulating crystal field parameters and their conversions
 *
 * (C) 2018-2026 Duc Le - duc.le@stfc.ac.uk
 * This program is licensed under the GNU General Purpose License, version 3. Please see the LICENSE file
 */

#include "cfpars.hpp"

namespace libMcPhase {

// --------------------------------------------------------------------------------------------------------------- //
// Reference tables (values taken from program cfield, by Peter Fabi, FZ Juelich, file theta.c)
// --------------------------------------------------------------------------------------------------------------- //

// Conversion factors from Stevens to Wybourn normalisation
static const std::array<double, 27> lambda = {
    {sqrt(6.)/2., sqrt(6.), 1./2., sqrt(6.), sqrt(6.)/2., // l=2
     sqrt(70.)/8., sqrt(35.)/2., sqrt(10.)/4., sqrt(5.)/2., 1./8., sqrt(5.)/2., sqrt(10.)/4., sqrt(35.)/2., sqrt(70.)/8., // l=4
     sqrt(231.)/16., 3*sqrt(77.)/8., 3*sqrt(14.)/16., sqrt(105.)/8., sqrt(105.)/16., sqrt(42.)/8., // l=6, m=-6 to m=-1
     1./16., sqrt(42.)/8., sqrt(105.)/16., sqrt(105.)/8., 3*sqrt(14.)/16., 3*sqrt(77.)/8., sqrt(231.)/16.} };

static const std::array<int, 27> id2l = { {0,0,0,0,0, 1,1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2,2,2,2,2,2} };

// Matching ion names to number of unfilled electrons in f-shell
static const std::unordered_map<std::string, int> ION_NUMBER_MAP = {
    {"ce3+",  1}, {"pr3+",  2}, {"nd3+",  3}, {"pm3+",  4}, {"sm3+",  5}, {"eu3+",  6}, {"gd3+",  7},
    {"tb3+",  8}, {"dy3+",  9}, {"ho3+", 10}, {"er3+", 11}, {"tm3+", 12}, {"yb3+", 13}, {"nd2+",  4},
    {"sm2+",  6}, {"eu2+",  7}, {"gd2+",  8}, {"tb2+",  9}, {"dy2+", 10}, {"ho2+", 11}, {"er2+", 12},
    {"tm2+", 13}, {"u4+",   2}, {"u3+",   3}, {"u2+",   4}, {"np4+",  3}, {"np3+",  4}, {"pu4+",  4},
    {"pu3+",  5} };

// Matching f-number to value of twice the total angular momentum J of the ground multiplet
static const std::array<int, 15> J2 = { { 0, 5, 8, 9, 8, 5, 0, 7, 12, 15, 16, 15, 12, 7, 0 } };

// Lande g-factor
static const std::array<double, 15> GJ = { { 0., 6./7, 0.8, 8./11, 0.6, 2./7, 0., 2., 1.5, 4./3, 1.25, 1.2, 7./6, 8./7 } };

static const std::array<double, 15> ALPHA_J = {{ // 2nd order Stevens Operator equivalent factor
    /* 4f_0        */    1.0 * 0                ,
    /* 4f_1 : Ce3+ */   -1.0 * 2/5/7            ,
    /* 4f_2 : Pr3+ */   -1.0 * 2*2*13/3/3/5/5/11,
    /* 4f_3 : Nd3+ */   -1.0 * 7/3/3/11/11      ,
    /* 4f_4 : Pm3+ */    1.0 * 2*7/3/5/11/11    ,
    /* 4f_5 : Sm3+ */    1.0 * 13/3/3/5/7       ,
    /* 4f_6 : Eu3+ */    1.0 * 0                ,
    /* 4f_7 : Gd3+ */    1.0 * 0                ,
    /* 4f_8 : Tb3+ */   -1.0 * 1/3/3/11         ,
    /* 4f_9 : Dy3+ */   -1.0 * 2/3/3/5/7        ,
    /* 4f_10: Ho3+ */   -1.0 * 1/2/3/3/5/5      ,
    /* 4f_11: Er3+ */    1.0 * 2*2/3/3/5/5/7    ,
    /* 4f_12: Tm3+ */    1.0 * 1/3/3/11         ,
    /* 4f_13: Yb3+ */    1.0 * 2/3/3/7          ,
    /* 4f_14       */    1.0 * 0
}};

static const std::array<double, 15> BETA_J = {{ // 4th order Stevens Operator equivalent factor
    /* 4f_0        */    1.0 * 0                              ,
    /* 4f_1 : Ce3+ */    1.0 * 2/3/3/5/7                      ,
    /* 4f_2 : Pr3+ */   -1.0 * 2*2/3/3/5/11/11                ,
    /* 4f_3 : Nd3+ */   -1.0 * 2*2*2*17/3/3/3/11/11/11/13     ,
    /* 4f_4 : Pm3+ */    1.0 * 2*2*2*7*17/3/3/3/5/11/11/11/13 ,
    /* 4f_5 : Sm3+ */    1.0 * 2*13/3/3/3/5/7/11              ,
    /* 4f_6 : Eu3+ */    1.0 * 0                              ,
    /* 4f_7 : Gd3+ */    1.0 * 0                              ,
    /* 4f_8 : Tb3+ */    1.0 * 2/3/3/3/5/11/11                ,
    /* 4f_9 : Dy3+ */   -1.0 * 2*2*2/3/3/3/5/7/11/13          ,
    /* 4f_10: Ho3+ */   -1.0 * 1/2/3/5/7/11/13                ,
    /* 4f_11: Er3+ */    1.0 * 2/3/3/5/7/11/13                ,
    /* 4f_12: Tm3+ */    1.0 * 2*2*2/3/3/3/3/5/11/11          ,
    /* 4f_13: Yb3+ */   -1.0 * 2/3/5/7/11                     ,
    /* 4f_14       */    1.0 * 0
}};

static const std::array<double, 15> GAMMA_J = {{ // 6th order Stevens Operator equivalent factor
    /* 4f_0        */    1.0 * 0                                 ,
    /* 4f_1 : Ce3+ */    1.0 * 0                                 ,
    /* 4f_2 : Pr3+ */    1.0 * 2*2*2*2*17/3/3/3/3/5/7/11/11/13   ,
    /* 4f_3 : Nd3+ */   -1.0 * 5*17*19/3/3/3/7/11/11/11/13/13    ,
    /* 4f_4 : Pm3+ */    1.0 * 2*2*2*17*19/3/3/3/7/11/11/11/13/13,
    /* 4f_5 : Sm3+ */    1.0 * 0                                 ,
    /* 4f_6 : Eu3+ */    1.0 * 0                                 ,
    /* 4f_7 : Gd3+ */    1.0 * 0                                 ,
    /* 4f_8 : Tb3+ */   -1.0 * 1/3/3/3/3/7/11/11/13              ,
    /* 4f_9 : Dy3+ */    1.0 * 2*2/3/3/3/7/11/11/13/13           ,
    /* 4f_10: Ho3+ */   -1.0 * 5/3/3/3/7/11/11/13/13             ,
    /* 4f_11: Er3+ */    1.0 * 2*2*2/3/3/3/7/11/11/13/13         ,
    /* 4f_12: Tm3+ */   -1.0 * 5/3/3/3/3/7/11/11/13              ,
    /* 4f_13: Yb3+ */    1.0 * 2*2/3/3/3/7/11/13                 ,
    /* 4f_14       */    1.0 * 0
}};

using Map3 = std::unordered_map<std::string, std::array<double, 3>>;

// Expectation value of radial wavefunction <r^k>, from theta.c in McPhase cf1ion_module source code.
void createRkTable(Map3 &rk) {
    rk["ce3+"] = {1.309, 3.964, 23.31}; 
    rk["pr3+"] = {1.1963, 3.3335, 18.353}; /* U. Walter Diss.         */
    rk["nd3+"] = {1.114, 2.910, 15.03}; 
    rk["pm3+"] = {1.0353, 2.5390, 12.546}; /*          -"-            */
    rk["sm3+"] = {0.9743, 2.260, 10.55}; 
    rk["eu3+"] = {0.9175, 2.020, 9.039}; 
    rk["gd3+"] = {0.8671, 1.820, 7.831}; 
    rk["tb3+"] = {0.8220, 1.651, 6.852}; 
    rk["dy3+"] = {0.7814, 1.505, 6.048}; 
    rk["ho3+"] = {0.7446, 1.379, 5.379}; 
    rk["er3+"] = {0.7111, 1.270, 4.816}; 
    rk["tm3+"] = {0.6804, 1.174, 4.340}; 
    rk["yb3+"] = {0.6522, 1.089, 3.932}; 
    rk["nd2+"] = {1.392, 5.344, 45.450}; 
    rk["sm2+"] = {1.197, 3.861, 28.560}; 
    rk["eu2+"] = {1.098, 3.368, 23.580}; 
    rk["gd2+"] = {1.028, 2.975, 19.850}; 
    rk["tb2+"] = {0.968, 2.655, 16.980}; 
    rk["dy2+"] = {0.913, 2.391, 14.730}; 
    rk["ho2+"] = {0.866, 2.169, 12.920}; 
    rk["er2+"] = {0.824, 1.979, 11.450}; 
    rk["tm2+"] = {0.785, 1.819, 10.240}; 
    rk["u4+"] = {2.042, 7.632, 47.774};    /* Freeman et al. PRB 13 (1976) 1168 */
    rk["u3+"] = {2.346, 10.906, 90.544};   /* Freeman et al. PRB 13 (1976) 1168 */
    rk["u2+"] = {3.257, 26.82, 462.85};    /* Lewis et al. J. Chem Phys. 53 (1970) 809 */
    rk["np4+"] = {1.884, 6.504, 37.80};    /* Lewis et al. J. Chem Phys. 53 (1970) 809 */
    rk["np3+"] = {2.297, 11.00, 98.63};    /* Lewis et al. J. Chem Phys. 53 (1970) 809 */
    rk["pu4+"] = {1.838, 6.401, 38.77};    /* Lewis et al. J. Chem Phys. 53 (1970) 809 */
    rk["pu3+"] = {2.1025, 9.1775, 73.3};   /* Lewis et al. J. Chem Phys. 53 (1970) 809 */
}

const Map3 &RKTABLE() {
    static Map3 rk_table;
    if (rk_table.empty()) 
        createRkTable(rk_table);
    return rk_table;
}

// Normalisation factors for Fabi parameters, defined as sqrt( sum_{Jz, Jz'} |<Jz|Olm|Jz'>|^2 / (2J+1) )
static const std::array< std::array<double, 27>, 17> FABINORM = {{
/* J=0 */   {0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.},
/* J=1/2 */ {0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.},
/* J=1 */   {-0.8164965809, -0.4082482905, 1.4142135624, 0.4082482905, 0.8164965809, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.},
/* J=3/2 */ {-1.7320508076, -0.8660254038, 3., 0.8660254038, 1.7320508076, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.},
/* J=2 */   {-2.8982753492, -1.4491376746, 5.0199601592, 1.4491376746, 2.8982753492, -7.5894663844, -2.683281573, -10.0399203184, -7.0992957397, 44.8998886413,
             7.0992957397, 10.0399203184, 2.683281573, 7.5894663844, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.},
/* J=5/2 */ {-4.3204937989, -2.1602468995, 7.4833147735, 2.1602468995, 4.3204937989, -21.9089023002, -7.7459666924, -28.9827534924, -20.4939015319, 129.6148139682,
             20.4939015319, 28.9827534924, 7.7459666924, 21.9089023002, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.},
/* J=3 */   {-6., -3., 10.3923048454, 3., 6., -47.5694980303, -16.8183573174, -62.9285308902, -44.4971909226, 281.4249455894, 44.4971909226, 62.9285308902,
             16.8183573174, 47.5694980303, -192.4280941769, -55.5492059864, -260.5488712041, -142.708494091, -285.416988182, -225.6419413901, 2068.0425527537,
             225.6419413901, 285.416988182, 142.708494091, 260.5488712041, 55.5492059864, 192.4280941769},
/* J=7/2 */ {-7.9372539332, -3.9686269666, 13.7477270849, 3.9686269666, 7.9372539332, -88.9943818451, -31.4642654451, -117.7285012221, -83.2466215531,
             526.4978632435, 83.2466215531, 117.7285012221, 31.4642654451, 88.9943818451, -673.4983296193, -194.4222209522, -911.9210492142, -499.4797293184,
             -998.9594586368, -789.7467948653, 7238.1489346379, 789.7467948653, 998.9594586368, 499.4797293184, 911.9210492142, 194.4222209522, 673.4983296193},
/* J=4 */   {-10.1324561024, -5.0662280512, 17.5499287748, 5.0662280512, 10.1324561024, -151.2613632095, -53.4789678285, -200.0999750125, -141.4920492466,
             894.8742928479, 141.4920492466, 200.0999750125, 53.4789678285, 151.2613632095, -1738.9652095427, -501.9960159204, -2354.5700244418, -1289.6511156123,
             -2579.3022312246, -2039.117456156, 18688.8201874811, 2039.117456156, 2579.3022312246, 1289.6511156123, 2354.5700244418, 501.9960159204, 1738.9652095427},
/* J=9/2 */ {-12.585706178, -6.292853089, 21.7990825495, 6.292853089, 12.585706178, -240.119970015, -84.895229548, -317.64886274, -224.6116648796, 1420.5689001242,
             224.6116648796, 317.64886274, 84.895229548, 240.119970015, -3809.881887933, -1099.8181667894, -5158.6044624491, -2825.4840293302, -5650.9680586604,
             -4467.4825125567, 40945.1535593652, 4467.4825125567, 5650.9680586604, 2825.4840293302, 5158.6044624491, 1099.8181667894, 3809.881887933,},
/* J=5 */   {-15.2970585408, -7.6485292704, 26.495282599, 7.6485292704, 15.2970585408, -361.994475096, -127.9843740462, -478.8736785416, -338.6148254285,
             2141.588195709, 338.6148254285, 478.8736785416, 127.9843740462, 361.994475096, -7488.7552066718, -2161.8174172336, -10139.8224836533, -5553.8095033949,
             -11107.6190067899, -8781.3438607083, 80482.3458902634, 8781.3438607083, 11107.6190067899, 5553.8095033949, 10139.8224836533, 2161.8174172336, 7488.7552066718},
/* J=11/2 */{-18.2665450118, -9.1332725059, 31.6385840391, 9.1332725059, 18.2665450118, -523.984732602, -185.2565788306, -693.1666466298, -490.1428363243, 3099.9354831996,
             490.1428363243, 693.1666466298, 185.2565788306, 523.984732602, -13603.9994119377, -3927.1363612689, -18419.9022798711, -10088.9959857262, -20177.9919714525,
             -15952.1033095953, 146203.4418199517, 15952.1033095953, 20177.9919714525, 10088.9959857262, 18419.9022798711, 3927.1363612689, 13603.9994119377},
/* J=6 */   {-21.4941852602, -10.7470926301, 37.229020938, 10.7470926301, 21.4941852602, -733.8664728682, -259.4609797253, -970.8140913687, -686.4692272783,
             4341.6126036301, 686.4692272783, 970.8140913687, 259.4609797253, 733.8664728682, -23258.7690659144, -6714.2282906125, -31492.5221893413, -17249.1647958342,
             -34498.3295916684, -27273.3242452147, 249964.1456135413, 27273.3242452147, 34498.3295916684, 17249.1647958342, 31492.5221893413, 6714.2282906125, 23258.7690659144},
/* J=13/2 */{-24.9799919936, -12.4899959968, 43.2666153056, 12.4899959968, 24.9799919936, -1000.0914243922, -353.5857139971, -1322.9965986351, -935.4998663816, 5916.6206570981,
             935.4998663816, 1322.9965986351, 353.5857139971, 1000.0914243922, -37884.3955814452, -10936.2829935168, -51295.7141066804, -28095.8197195648, -56191.6394391296,
             -44423.391521649, 407147.1085492319, 44423.391521649, 56191.6394391296, 28095.8197195648, 51295.7141066804, 10936.2829935168, 37884.3955814452},
/* J=7 */   {-28.723973727, -14.3619868635, 49.7513818904, 14.3619868635, 28.723973727, -1331.7873704162, -470.8579403599, -1761.7890906689, -1245.7730130325,
             7878.9603375065, 1245.7730130325, 1761.7890906689, 470.8579403599, 1331.7873704162, -59298.458664623, -17117.990536275, -80290.4925878525, -43976.9139435682,
             -87953.8278871363, -69533.6062634465, 637286.0280909977, 69533.6062634465, 87953.8278871363, 43976.9139435682, 80290.4925878525, 17117.990536275, 59298.458664623},
/* J=15/2 */{-32.7261363439, -16.363068172, 56.6833308831, 16.363068172, 32.7261363439, -1738.7581775509, -614.7438490949, -2300.1608639397, -1626.4593447117, 10286.6321019078,
             1626.4593447117, 2300.1608639397, 614.7438490949, 1738.7581775509, -89767.4996866906, -25913.6450542952, -121545.7691571368, -66573.3595366795, -133146.7190733591,
             -105261.7238125996, 964739.6343055468, 105261.7238125996, 133146.7190733591, 66573.3595366795, 121545.7691571368, 25913.6450542952, 89767.4996866906},
/* J=8 */   {-36.9864840178, -18.4932420089, 64.0624695122, 18.4932420089, 36.9864840178, -2231.4838112789, -788.9486675317, -2951.9756096553, -2087.3619714846,
             13201.6362622214, 2087.3619714846, 2951.9756096553, 788.9486675317, 2231.4838112789, -132074.3790445369, -38126.589147208, -178829.5546043774, -97948.9810054194,
             -195897.9620108387, -154870.9372348473, 1419415.585654885, 154870.9372348473, 195897.9620108387, 97948.9810054194, 178829.5546043774, 38126.589147208, 132074.3790445369},
}};

// Point symmetry tables - classes are triclinic, monoclinic, etc. to cubic
static const std::array<int, 10> SYM_CLASS = {{ 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 }};
static const std::array<int, 27> BLM_SYM = {{ 3, 1, 511, 1, 7, 11, 33, 3, 1, 1023, 1, 7, 97, 543, 163, 1, 11, 33, 3, 1, 1023, 1, 7, 97, 543, 1, 999 }}; 

// --------------------------------------------------------------------------------------------------------------- //
// General methods for cfpars class
// --------------------------------------------------------------------------------------------------------------- //
void cfpars::getfromionname(const std::string &ionname) {
	std::string ion = ionname;
	std::transform(ion.begin(), ion.end(), ion.begin(), [](unsigned char c) { return std::tolower(c); });
    auto ion_number = ION_NUMBER_MAP.find(ion);
    if (ion_number == ION_NUMBER_MAP.end()) {
        throw std::runtime_error("Unknown ion");
    }
    m_ionname = ion;
    m_n = ion_number->second;
	m_J2 = J2[m_n];
    const Map3 &rktable = RKTABLE();
	auto rk_table = rktable.find(ion);
	m_rk = rk_table->second;
}

bool cfpars::is_sym_allowed(const Blm blm) {
    return BLM_SYM[(int)blm] & SYM_CLASS[(int)m_sym/10];
}

std::vector<cfpars::Blm> cfpars::get_sym_allowed_Blm() {
    std::vector<cfpars::Blm> rv;
    int sy = (int)m_sym/10;
    for (int i=0; i<27; i++) {
        if (BLM_SYM[i] & SYM_CLASS[sy]) rv.push_back(static_cast<Blm>(i));
    }
    return rv;
}

// --------------------------------------------------------------------------------------------------------------- //
// Setter/getter methods for cfpars class
// --------------------------------------------------------------------------------------------------------------- //
void cfpars::set(const Blm blm, double val) {
    if (!is_sym_allowed(blm)) {
        throw std::runtime_error("cfpars::set() Parameter not allowed by symmetry"); }
    int id = (int)blm;
    m_Bo[id] = val;
    m_Bi[id] = val / m_convfact[id] / m_econv;
}

void cfpars::set(int l, int m, double val) {
    int id;
    switch(l) {
        case 2: id = 2 + m; break;
        case 4: id = 9 + m; break;
        case 6: id = 20 + m; break;
        default:
            return;
    }
    if (!is_sym_allowed(static_cast<Blm>(id))) {
        throw std::runtime_error("cfpars::set() Parameter not allowed by symmetry"); }
    m_Bo[id] = val;
    m_Bi[id] = val / m_convfact[id] / m_econv;
}

double cfpars::get(int l, int m) const {
    switch(l) {
        case 2: return m_Bo[2 + m];
        case 4: return m_Bo[9 + m];
        case 6: return m_Bo[20 + m];
        default:
            return 0.0;
    }
}

void cfpars::set_unit(cfpars::Units const newunit) {
    if (m_unit == newunit)
        return;
    m_unit = newunit;
    m_econv = ENERGYCONV[(int)m_unit];
    for (int id=0; id<27; id++) {
        m_Bo[id] = m_Bi[id] * m_econv * m_convfact[id];
    }
}

void cfpars::set_type(const cfpars::Type newtype) {
    if (!m_convertible) {
        throw std::runtime_error("Unknown ion, cannot set parameter type. Please set the ionname on construction.");
    }
    switch(newtype) {
        case cfpars::Type::Alm:
            for (int id=0; id<27; id++)
                if(m_stevfact[id2l[id]] != 0)
                    m_convfact[id] = lambda[id] / m_stevfact[id2l[id]] / m_rk[id2l[id]];
            break;
        case cfpars::Type::ARlm:
            for (int id=0; id<27; id++) 
                if(m_stevfact[id2l[id]] != 0)
                    m_convfact[id] = lambda[id] / m_stevfact[id2l[id]];
            break;
        case cfpars::Type::Blm:
            for (int id=0; id<27; id++) 
                    m_convfact[id] = lambda[id];
            break;
        case cfpars::Type::Llm:
            for (int id=0; id<27; id++)
                if(m_stevfact[id2l[id]] != 0)
                    m_convfact[id] = 1. / m_stevfact[id2l[id]];
            break;
        case cfpars::Type::Nlm:
            for (int id=0; id<27; id++)
                m_convfact[id] = lambda[id] / FABINORM[m_J2][id];
            break;
    }
    for (int id=0; id<27; id++)
        m_Bo[id] = m_Bi[id] * m_convfact[id] * m_econv;
    m_type = newtype;
    if(newtype == cfpars::Type::Llm)
        m_norm = cfpars::Normalisation::Wybourne;
    else
        m_norm = cfpars::Normalisation::Stevens;
}

void cfpars::set_name(const std::string &ionname) {
    getfromionname(ionname);
    double alpha = ALPHA_J[m_n];
    double beta = BETA_J[m_n];
    double gamma = GAMMA_J[m_n];
    // Scales parameters by ratio of Stevens factor of old and new ion (if old ion defined).
    if (m_convertible) {
        std::array<double, 3> scale = { {alpha/m_stevfact[0], beta/m_stevfact[1], gamma/m_stevfact[2]} };
        for (int id=0; id<27; id++)
            m_Bi[id] *= scale[id2l[id]];
    } 
    else {
        for (int id=0; id<27; id++)
            m_Bi[id] = m_Bo[id] / m_econv;
    }
	m_stevfact = {alpha, beta, gamma};
	m_convertible = true;
    m_GJ = GJ[m_n];
    // Now reset the conversion table (from internal to external parameters)
    this->set_type(m_type);
}

void cfpars::set_J(const double J) {
    if (fmod(2 * J, 1.) == 0.) {
        m_J2 = (int)(2 * J);
    }
    else {
        throw std::runtime_error("Invalid value of J - must be integer or half-integer");
    }
    m_ionname = "";
    m_stevfact = {1., 1., 1.};
    m_rk = {0., 0., 0.};
    m_convertible = false;
    m_convfact = lambda;
    for (int id=0; id<27; id++) {
        m_Bi[id] = m_Bo[id] / m_econv;
    }
    m_norm = cfpars::Normalisation::Stevens;
    m_type = Type::Blm;
}

// --------------------------------------------------------------------------------------------------------------- //
// Constructor functions for cfpars class
// --------------------------------------------------------------------------------------------------------------- //
cfpars::cfpars() {
    m_convfact = lambda;
}

cfpars::cfpars(int J2) {
    m_J2 = J2;
    m_convfact = lambda;
}

cfpars::cfpars(const double J) {
    if (fmod(2 * J, 1.) == 0.) {
        m_J2 = (int)(2 * J);
    }
    else {
        throw std::runtime_error("Invalid value of J - must be integer or half-integer");
    }
    m_convfact = lambda;
}

cfpars::cfpars(const std::string &ionname) {
    getfromionname(ionname);
    double alpha = ALPHA_J[m_n];
    double beta = BETA_J[m_n];
    double gamma = GAMMA_J[m_n];
    m_convfact = lambda;
	m_stevfact = {alpha, beta, gamma};
	m_convertible = true;
}

} // namespace libMcPhase
